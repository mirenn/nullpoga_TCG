# ヌルポガ TCG 要件定義書

## 1. プロジェクト概要

### 1.1 プロジェクト名
デジタルカードゲーム「ヌルポガ」

### 1.2 プロジェクト目的
独自のルールと戦略性を持つデジタルカードゲームを開発し、ユーザーに新しいゲーム体験を提供する。

### 1.3 開発プラットフォーム
- フロントエンド: React
- バックエンド: Nest.js

## 2. ゲーム仕様

### 2.1 基本ルール

#### 2.1.1 ゲーム形式
- 同時決定・同時実行型のターン制カードゲーム
- 1ターンは3つのフェイズ（スペルフェイズ、進軍召喚フェイズ、行動フェイズ）に分けられる
- 各プレイヤーは、相手の行動を知ることなく、各フェイズでの全アクション（使用カード、召喚位置、攻撃など）を事前に決定する
- アクション計画が両プレイヤーからサーバーに提出された後に初めて処理が実行され、その時点で初めて相手の行動が明らかになる
- この「見えない意思決定」と「同時実行」がゲームの戦略的核心となる

#### 2.1.2 リソース管理
- マナコスト制
- 毎ターン使用可能マナが1増加
- 開始マナ1、最大10マナ

#### 2.1.3 フィールド構成
- 横5列のゾーン構造
- スタンバイゾーン：モンスターを召喚する場所
- バトルゾーン：モンスターが行動する場所

#### 2.1.4 カード管理
- スペルカードとモンスターカードの2種類
- デッキは30枚構成
- 同名カードは2枚まで
- 初期ドロー5枚、毎ターン1枚ドロー

#### 2.1.5 勝利条件
- 相手のライフ20を削りきる
- 相手の連続した4つのバトルゾーンを荒野状態にする
- 同時に勝利条件を達成した場合、ライフが高い方が勝者（同値なら引き分け）

### 2.2 ゲームフロー

#### 2.2.1 ゲーム開始
- 各プレイヤーは事前に構築した30枚のデッキを用意
- 各プレイヤーは初期手札として5枚をドロー

#### 2.2.2 ターン進行の全体構造
1. **計画フェーズ**
   - 両プレイヤーは同時並行で以下のすべてのフェイズのアクションを計画
   - 計画内容はUI上で仮配置・仮設定として表示されるが、実際には未実行
   - 計画が完了したら「ターン終了」ボタンでサーバーに提出
   - 相手プレイヤーも提出するまで待機状態となる

2. **実行フェーズ**
   - 両プレイヤーの計画が提出された後、サーバーで以下の順に処理を実行
   - 実行した最終結果および履歴情報がサーバーから返却されるので、両プレイヤーの行動が順次アニメーション表示され、結果が反映される
   - すべての処理が終了した後、次のターンの計画フェーズに移行

3. **個別フェイズの処理順序**
   - ターン開始処理
   - スペルフェイズ（複数サブフェイズに分かれる場合あり）
   - 進軍召喚フェイズ
   - 行動フェイズ
   - ターン終了処理

#### 2.2.3 ターン進行
1. **ターン開始処理**
   - 使用可能マナが1増加（最大10）
   - カードを1枚ドロー
   - ターン開始時効果の発動

2. **スペルフェイズ**
   - プレイヤーはスペルカードを使用可能
   - スペルフェイズは複数に細分化される（スペルフェイズ1,2,...N）
   - 同じフェイズ内での処理順はカードナンバーが小さい順

3. **進軍召喚フェイズ**
   - プレイヤーはモンスターを召喚可能
   - すでに召喚されているモンスターがスタンバイゾーンにいる場合はバトルゾーンに進軍可能
   - 召喚されたばかりのモンスターは次のターンまで進軍不可

4. **行動フェイズ**
   - バトルゾーンのモンスターは攻撃または移動が可能
   - 行動フェイズは移動フェイズと攻撃フェイズに分けられる
   - 移動処理完了後に攻撃処理を実行

5. **ターン終了処理**
   - ターン終了時効果の発動
   - 勝利条件の確認

#### 2.2.4 スペルフェイズの処理
- **計画時**: プレイヤーは使用するスペルカードと対象を選択
- **実行時**: カードナンバーが小さい順に処理（両プレイヤーの同名カードが競合した場合は不発条件を適用）
- スペルフェイズが複数ある場合は、順番に処理（スペルフェイズ1→2→...N）
- スペルの効果は即時適用され、以降のフェイズに影響を与える
- **不発条件**: 同じスペルフェイズ内で両プレイヤーが同名のカードを使用した場合、処理順序によって結果が異なるときは不発となる
  - サーバーが処理を行うとき、Aプレイヤーの同名カードを先に処理した場合とBプレイヤーの同名カードを先に処理した場合で結果が異なる場合に不発処理が適用される
  - これは公平性を担保するためのルールであり、同名カードの処理順序による不公平な結果を防止する

#### 2.2.5 進軍召喚フェイズの処理
- **計画時**: プレイヤーは召喚するモンスターとその配置位置、および進軍させるモンスターを選択
- **実行時**: 両プレイヤーの召喚が同時に処理され、その後進軍処理が行われる
- 召喚処理の競合（同じスタンバイゾーンに配置しようとした場合など）は特定のルールで解決
- 召喚されたばかりのモンスターは、そのターンの行動フェイズでは行動できない

#### 2.2.6 行動フェイズの処理
- **計画時**: プレイヤーは各モンスターを移動か攻撃か選択
- **実行時**: 移動処理が先に実行され、その後攻撃処理が実行される
- 移動と攻撃の両方が計画された場合、移動後の位置から攻撃が行われる
- 攻撃処理の競合（相互攻撃など）は同時ダメージとして処理

#### 2.2.7 アクション競合の解決
- 同じ対象への効果: 先に処理されるカード・モンスターの効果が優先
- 同時攻撃: 双方が同時にダメージを受ける
- 移動競合: 特定の優先順位（例：カードID順）で解決
- 効果の不発条件: 同名カードの競合などの特定条件下で効果が不発になるケース

#### 2.2.8 戦闘処理
- モンスター同士の攻撃：攻撃力分のダメージを与える
- プレイヤーへの攻撃：対面するバトルゾーンに相手モンスターがいない場合、モンスターの攻撃力分相手プレイヤーのライフを減らし、そのバトルゾーンが荒野状態となる

## 3. 機能要件

### 3.1 ユーザーインターフェース

#### 3.1.1 ゲーム画面
- フィールド表示（スタンバイゾーン、バトルゾーン）
- 手札表示
- プレイヤー情報表示（ライフ、マナ）
- フェイズ表示
- ターン表示

#### 3.1.2 アクション操作
- カード選択機能
- ゾーン選択機能
- モンスター選択機能
- フェイズ終了ボタン
- ターン終了ボタン

#### 3.1.3 アクション計画・実行UI
- アクション計画表示: 現在計画中のアクションを視覚的に表示
- 仮配置表示: モンスターの召喚位置や移動先を仮表示
- 矢印表示: 攻撃対象や効果対象への方向を表示
- 提出ボタン: すべての計画を完了し提出するためのボタン
- 待機表示: 相手の計画提出を待つ間の表示
- 実行アニメーション: アクションの実行過程を視覚的に表示

### 3.2 カード機能

#### 3.2.1 モンスターカード
- 基本ステータス（攻撃力、ライフ、マナコスト）
- 特殊能力（移動、攻撃、状態異常付与など）
- 成長能力（カエル三等兵のような成長するモンスター）

#### 3.2.2 スペルカード
- 単体効果（ダメージ、強化、弱体化）
- 範囲効果（全体ダメージ、複数対象への効果）
- フィールド効果（ゾーン状態変化、モンスター配置変更）

### 3.3 状態管理

#### 3.3.1 ゲーム状態
- 盤面状態（各ゾーンのモンスター情報）
- プレイヤー状態（ライフ、マナ、手札）
- フェイズ状態（現在のフェイズ、残りアクション）
- ターン状態（現在のターン、経過ターン数）

#### 3.3.2 モンスター状態
- 通常状態
- 行動不能状態（スタン、凍結など）
- 強化状態（攻撃力増加、無敵など）
- 弱体化状態（毒、燃焼など）

## 4. 技術要件

### 4.1 フロントエンド（React）

#### 4.1.1 コンポーネント
- GameBoard：ゲーム盤面全体
- Hand：プレイヤーの手札
- PlayerStats：プレイヤー情報
- OpponentStats：対戦相手情報
- MonsterCard：モンスターカード表示
- ButtonContainer：アクションボタン
- ResultContainer：結果表示

#### 4.1.2 状態管理
- ゲーム状態管理（gameContext）
- 認証状態管理（authContext）

### 4.2 バックエンド（Nest.js）

#### 4.2.1 モジュール構成
- Auth：認証・認可
- Core：ゲームコアロジック
- Game-APIs：ゲームAPIエンドポイント

#### 4.2.2 モデル
- Card：カード情報
- Player：プレイヤー情報
- State：ゲーム状態
- Zone：ゾーン情報
- Action：アクション情報
- Phase：フェイズ情報

### 4.3 API仕様

#### 4.3.1 ゲーム状態API
- `GET /game_state/{user_id}`：現在のゲーム状態を取得

#### 4.3.2 アクション提出API
- `POST /submit_action_with_random_cpu/{user_id}`：プレイヤーのアクションを提出し、CPUの行動を決定。一人で開発してテストするため用
- `POST /submit_actions/{game_id}/{user_id}`: 計画したすべてのアクションを一括提出
- `GET /action_status/{game_id}`: 両プレイヤーのアクション提出状況を確認
- `GET /execute_actions/{game_id}`: 両者のアクションが提出された場合に処理を実行

#### 4.3.3 ゲーム管理API
- 攻撃実行API：ユニット間の攻撃処理を実行
- 攻撃宣言API：攻撃するユニットと対象を指定
- 召喚実行API：手札からユニットを場に出す
- フェーズ終了API：現在のフェーズを終了して次に進む
- 進軍処理API：ユニットの移動を処理
- ターン終了API：現在のターンを終了して次のターンへ
- ゲーム終了判定API：勝敗条件を満たしているか確認

## 5. 実装計画

### 5.1 優先実装機能
1. ゲーム状態取得機能（高優先）
2. アクション提出機能（高優先）
   - 召喚アクション（実装済み）
   - 攻撃アクション
3. 攻撃実行機能（高優先）
4. 攻撃宣言機能（高優先）
5. 召喚実行機能（高優先）
6. フェーズ終了機能（高優先）

### 5.2 次期実装機能
1. 進軍処理機能（中優先）
2. ターン終了機能（中優先）
3. ゲーム終了判定機能（中優先）
4. スペル実装（中優先）
5. 特殊効果モンスター実装（中優先）

### 5.3 将来拡張機能
1. マルチプレイヤー対戦機能
2. カードコレクション機能
3. デッキビルド機能
4. ランキングシステム
5. チュートリアルモード

## 6. 品質要件

### 6.1 性能要件
- レスポンス時間：アクション提出から結果表示まで1秒以内
- 同時接続数：初期は最大100ユーザー

### 6.2 セキュリティ要件
- ユーザー認証：JWT認証
- データ保護：HTTPS通信

### 6.3 テスト要件
- ユニットテスト：コアロジックのテスト（Player, State等）
- 統合テスト：APIエンドポイントのテスト
- E2Eテスト：ゲームの一連の流れのテスト

## 7. 制約事項と前提条件

### 7.1 技術的制約
- フロントエンド：React
- バックエンド：Nest.js
- データ形式：JSON

### 7.2 環境前提
- ブラウザ対応：最新のChrome, Firefox, Safari, Edge
- レスポンシブ対応：PC優先、タブレット対応（スマートフォンは将来対応）